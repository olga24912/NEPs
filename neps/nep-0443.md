---
NEP: 443
Title: Efficient BLS-signature verification
Author: Olga Kuniavskaia <olga.kunyavskaya@aurora.dev>
DiscussionsTo: https://github.com/nearprotocol/neps/pull/443
Status: Draft
Type: Runtime Spec
Category: Contract
Created: 14-Dec-2022
---

## Summary

This NEP introduces the request of adding into the NEAR runtime a pre-compiled
function used to verify BLS12-381 signatures that help to run Ethereum 2 light clients on-chain.

## Motivation

For proper work of the Rainbow Bridge, the ETH2 Light Client should be implemented 
as a NEAR contract. Inside the ETH2 Light Client, it is necessary to verify 
BLS12-381 signatures. At the moment, there are no practical implementations 
of BLS signatures that (1) have been audited, (2) could be compiled into a wasm file, 
and (3) would fit into the gas limit.

Because of this, at the moment, verification of BLS signatures 
in the Rainbow Bridge is performed out-of-chain, which makes it not trustless, 
as we would like. This proposal is dedicated to adding the ability 
to verify the correctness of the aggregated BLS12-381 signature to the NEAR level, 
which will allow us to further verify ETH2 data completely on NEAR and make Rainbow Bridge
trustless.

## Rationale and alternatives

One of the core part of the Rainbow Bridge is the Ethereum Light Client implemented on NEAR. For proper work 
of the Eth2 light client we should verify the correctness of the Light Client Update and for that we should verify 
the BLS signature which used in Eth2. 

The main alternative is to implement BLS verification as a smart contract and use for that already existing libraries.

The list of the Rust libraries for the BLS signature verification: 
* [BLST](https://github.com/supranational/blst) (used by Lighthouse by default), Rust bindings to C-library implementation by Supranational team. Has some audits, some are in progress. 
* [sigp/milagro-bls](https://github.com/sigp/milagro_bls). Implemented by SigmaPrime, uses The Apache Milagro Cryptographic Library. Optionally could be enabled in LightHouse. Not Audited. 
* [filecoin/bls-signatures](https://github.com/filecoin-project/bls-signatures). Implementation of BLS signatures in pure Rust. Not Audited. 
* [zkcrypto/bls12-381](https://github.com/zkcrypto/bls12_381) (zk-crypto implementation. By ZCash developers) Not Audited.

The best solution is to use BLST library because it both showed good performance and was audited. Unfortunately,
we can not use it inside smart contract because it can not be compiled into WASM file.

For signature verification we try to use `milagro-bls` library inside smart contract. Unfortunately, the BLS-signature 
verification is super gas-consuming operation and there is a gas limit in NEAR for one contract function call. In case 
of using  this library we exceed the gas limit dozens of times.

Alternatively, one could consider trying to split the signature verification function into multiple iterations, 
or developing a faster, smart contract-compatible implementation on our own. 
However, such development will take a lot of time and will require many checks(and audits) to make sure that 
it is correct and there is no guarantee that we will succeed in it.

Currently, signature verification is performed off-chain using the DAO. 
Because of this, the Rainbow Bridge cannot be considered trustless. 
It is impact of not implementing this function. 

The current idea is to make the BLS-signature verification as NEAR runtime pre-compiled function and in that case
we can use a fast and audited BLST library, and the calculation shows that in that case, we fit into the gas limit.

The PR with implementation and gas calculation: https://github.com/near/nearcore/pull/8184

## Specificationexsisting

This NEP aims to introduce the following host function:

```rust
extern "C" {
  /// Verify aggregate BLS12-381 signature for given message and
  /// public keys list (or one aggregate public key)
  ///
  /// The length of each public key(include aggregate one) should be 48 bytes and
  /// the length of the signature is 96 bytes.
  ///
  /// In case of providing the list of public keys, all public keys should be written
  /// in one slice one by one without any separation. `pubkeys_ptr` - the pointer
  /// to the beginning of this slice and `pubkeys_len` the len of this
  /// slice in bytes (=48 * PUBLIC_KEYS_CNT).
  ///
  /// Returns 1 if the signature verification pass, and 0 if verification fail.
  ///
  /// # Errors
  ///
  /// If the input data is incorrect contract execution is terminated with an error.
  ///
  /// # Cost
  ///
  /// `input_cost(aggregate_signature_len) + input_cost(msg_len) + input_cost(pubkey_len) +
  ///  bls12381_verify_base + bls12381_verify_byte * msg_len + bls12381_verify_elements * pubkeys_cnt`
  ///
  /// Where `pubkeys_cnt` -- the number of public keys (`pubkeys_len/48`).
  ///
  /// The signature_len is a const = 96 bytes. And for signature verification, first,
  /// the public keys are aggregated into one public key and after that the signature is verified,
  /// so public keys number and message len influence on cost independently.
  fn bls12_381_aggregate_verify(
    aggregate_signature_ptr: u64,
    aggregate_signature_len: u64,
    msg_ptr: u64,
    msg_len: u64,
    pubkeys_ptr: u64,
    pubkeys_len: u64,
  ) -> u64;
}
```

And a `rust-sdk` possible implementation could look like this:

```rs
pub fn bls12_381_aggregate_verify(aggregate_signature: &[u8], msg: &[u8], pubkeys: &[u8]) -> u64;
```
Once this NEP is approved and integrated, these functions will be available in the `near_sdk` crate in the
`env` module.

The main goal is to be able to check the sync committee signature of light client update for Ethereum 2. The example of usage for verification:
```rust
near_sdk::env::bls12_381_aggregate_verify(
    &light_client_update
     .sync_aggregate
     .sync_committee_signature.0,
    &signing_root.0.as_bytes(),
    &pubkeys
);
```
Where `signing_root` is a tree_hash of `light_client_update.attested_beacon_header` and `pubkeys` 
is concatenation of the subset of `sync_committee.pubkeys`(only pubkeys which signed light client update aka corresponding bit in `light_client_update.sync_aggregate.sync_committee_bits` set as 1).

For verification inside `bls12_381_aggregate_verify` function the blst library(https://github.com/supranational/blst) is used, 
more specifically the `fast_aggregate_verify`. The PR with implementation: https://github.com/near/nearcore/pull/8184

## Security Implications (Optional)

The security of a function depends on the security of the library used. 
We suggest using the blst library(https://github.com/supranational/blst). This library were audited and shows the good performance.

## Future possibilities

The Ethereum 2 supports the following precompile operations for BLS12-381: https://eips.ethereum.org/EIPS/eip-2537
In the future it can be usefully to support these operations on NEAR as well to be able 
effectively execute Ethereum 2 contracts on NEAR.

## Copyright

[copyright]: #copyright

Copyright and related rights waived via [CC0](https://creativecommons.org/publicdomain/zero/1.0/).
